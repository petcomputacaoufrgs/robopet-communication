// Generated by the protocol buffer compiler.  DO NOT EDIT!

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "messages_robocup_ssl_wrapper.pb.h"
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace {

const ::google::protobuf::Descriptor* SSL_WrapperPacket_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  SSL_WrapperPacket_reflection_ = NULL;

}  // namespace


void protobuf_AssignDesc_messages_5frobocup_5fssl_5fwrapper_2eproto() {
  protobuf_AddDesc_messages_5frobocup_5fssl_5fwrapper_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "messages_robocup_ssl_wrapper.proto");
  GOOGLE_CHECK(file != NULL);
  SSL_WrapperPacket_descriptor_ = file->message_type(0);
  static const int SSL_WrapperPacket_offsets_[11] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SSL_WrapperPacket, detection_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SSL_WrapperPacket, geometry_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SSL_WrapperPacket, refbox_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SSL_WrapperPacket, aitogui_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SSL_WrapperPacket, aitoradio_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SSL_WrapperPacket, aitosim_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SSL_WrapperPacket, guitoai_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SSL_WrapperPacket, simtotracker_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SSL_WrapperPacket, trackertoai_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SSL_WrapperPacket, aitotracker_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SSL_WrapperPacket, radiototracker_),
  };
  SSL_WrapperPacket_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      SSL_WrapperPacket_descriptor_,
      SSL_WrapperPacket::default_instance_,
      SSL_WrapperPacket_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SSL_WrapperPacket, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SSL_WrapperPacket, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(SSL_WrapperPacket));
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_messages_5frobocup_5fssl_5fwrapper_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    SSL_WrapperPacket_descriptor_, &SSL_WrapperPacket::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_messages_5frobocup_5fssl_5fwrapper_2eproto() {
  delete SSL_WrapperPacket::default_instance_;
  delete SSL_WrapperPacket_reflection_;
}

void protobuf_AddDesc_messages_5frobocup_5fssl_5fwrapper_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::protobuf_AddDesc_message_5fai_5fto_5fgui_2eproto();
  ::protobuf_AddDesc_message_5fai_5fto_5fradio_2eproto();
  ::protobuf_AddDesc_message_5fai_5fto_5fsim_2eproto();
  ::protobuf_AddDesc_message_5fgui_5fto_5fai_2eproto();
  ::protobuf_AddDesc_message_5fsim_5fto_5ftracker_2eproto();
  ::protobuf_AddDesc_messages_5frobocup_5fssl_5fdetection_2eproto();
  ::protobuf_AddDesc_messages_5frobocup_5fssl_5fgeometry_2eproto();
  ::protobuf_AddDesc_messages_5frobocup_5fssl_5frefbox_5flog_2eproto();
  ::protobuf_AddDesc_message_5ftracker_5fto_5fai_2eproto();
  ::protobuf_AddDesc_message_5fai_5fto_5ftracker_2eproto();
  ::protobuf_AddDesc_message_5fradio_5fto_5ftracker_2eproto();
  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n\"messages_robocup_ssl_wrapper.proto\032\027me"
    "ssage_ai_to_gui.proto\032\031message_ai_to_rad"
    "io.proto\032\027message_ai_to_sim.proto\032\027messa"
    "ge_gui_to_ai.proto\032\034message_sim_to_track"
    "er.proto\032$messages_robocup_ssl_detection"
    ".proto\032#messages_robocup_ssl_geometry.pr"
    "oto\032%messages_robocup_ssl_refbox_log.pro"
    "to\032\033message_tracker_to_ai.proto\032\033message"
    "_ai_to_tracker.proto\032\036message_radio_to_t"
    "racker.proto\"\201\003\n\021SSL_WrapperPacket\022&\n\tde"
    "tection\030\001 \001(\0132\023.SSL_DetectionFrame\022#\n\010ge"
    "ometry\030\002 \001(\0132\021.SSL_GeometryData\022\033\n\006refbo"
    "x\030\003 \001(\0132\013.Refbox_Log\022\031\n\007aiToGui\030\004 \001(\0132\010."
    "AIToGUI\022\035\n\taiToRadio\030\005 \001(\0132\n.AIToRadio\022\031"
    "\n\007aiToSim\030\006 \001(\0132\010.AIToSim\022\031\n\007guiToAi\030\007 \001"
    "(\0132\010.GUIToAI\022#\n\014simToTracker\030\010 \001(\0132\r.Sim"
    "ToTracker\022!\n\013trackerToAi\030\t \001(\0132\014.Tracker"
    "ToAI\022!\n\013aiToTracker\030\n \001(\0132\014.AIToTracker\022"
    "\'\n\016radioToTracker\030\013 \001(\0132\017.RadioToTracker", 760);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "messages_robocup_ssl_wrapper.proto", &protobuf_RegisterTypes);
  SSL_WrapperPacket::default_instance_ = new SSL_WrapperPacket();
  SSL_WrapperPacket::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_messages_5frobocup_5fssl_5fwrapper_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_messages_5frobocup_5fssl_5fwrapper_2eproto {
  StaticDescriptorInitializer_messages_5frobocup_5fssl_5fwrapper_2eproto() {
    protobuf_AddDesc_messages_5frobocup_5fssl_5fwrapper_2eproto();
  }
} static_descriptor_initializer_messages_5frobocup_5fssl_5fwrapper_2eproto_;


// ===================================================================

#ifndef _MSC_VER
const int SSL_WrapperPacket::kDetectionFieldNumber;
const int SSL_WrapperPacket::kGeometryFieldNumber;
const int SSL_WrapperPacket::kRefboxFieldNumber;
const int SSL_WrapperPacket::kAiToGuiFieldNumber;
const int SSL_WrapperPacket::kAiToRadioFieldNumber;
const int SSL_WrapperPacket::kAiToSimFieldNumber;
const int SSL_WrapperPacket::kGuiToAiFieldNumber;
const int SSL_WrapperPacket::kSimToTrackerFieldNumber;
const int SSL_WrapperPacket::kTrackerToAiFieldNumber;
const int SSL_WrapperPacket::kAiToTrackerFieldNumber;
const int SSL_WrapperPacket::kRadioToTrackerFieldNumber;
#endif  // !_MSC_VER

SSL_WrapperPacket::SSL_WrapperPacket()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void SSL_WrapperPacket::InitAsDefaultInstance() {
  detection_ = const_cast< ::SSL_DetectionFrame*>(&::SSL_DetectionFrame::default_instance());
  geometry_ = const_cast< ::SSL_GeometryData*>(&::SSL_GeometryData::default_instance());
  refbox_ = const_cast< ::Refbox_Log*>(&::Refbox_Log::default_instance());
  aitogui_ = const_cast< ::AIToGUI*>(&::AIToGUI::default_instance());
  aitoradio_ = const_cast< ::AIToRadio*>(&::AIToRadio::default_instance());
  aitosim_ = const_cast< ::AIToSim*>(&::AIToSim::default_instance());
  guitoai_ = const_cast< ::GUIToAI*>(&::GUIToAI::default_instance());
  simtotracker_ = const_cast< ::SimToTracker*>(&::SimToTracker::default_instance());
  trackertoai_ = const_cast< ::TrackerToAI*>(&::TrackerToAI::default_instance());
  aitotracker_ = const_cast< ::AIToTracker*>(&::AIToTracker::default_instance());
  radiototracker_ = const_cast< ::RadioToTracker*>(&::RadioToTracker::default_instance());
}

SSL_WrapperPacket::SSL_WrapperPacket(const SSL_WrapperPacket& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void SSL_WrapperPacket::SharedCtor() {
  _cached_size_ = 0;
  detection_ = NULL;
  geometry_ = NULL;
  refbox_ = NULL;
  aitogui_ = NULL;
  aitoradio_ = NULL;
  aitosim_ = NULL;
  guitoai_ = NULL;
  simtotracker_ = NULL;
  trackertoai_ = NULL;
  aitotracker_ = NULL;
  radiototracker_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SSL_WrapperPacket::~SSL_WrapperPacket() {
  SharedDtor();
}

void SSL_WrapperPacket::SharedDtor() {
  if (this != default_instance_) {
    delete detection_;
    delete geometry_;
    delete refbox_;
    delete aitogui_;
    delete aitoradio_;
    delete aitosim_;
    delete guitoai_;
    delete simtotracker_;
    delete trackertoai_;
    delete aitotracker_;
    delete radiototracker_;
  }
}

void SSL_WrapperPacket::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* SSL_WrapperPacket::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return SSL_WrapperPacket_descriptor_;
}

const SSL_WrapperPacket& SSL_WrapperPacket::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_5frobocup_5fssl_5fwrapper_2eproto();  return *default_instance_;
}

SSL_WrapperPacket* SSL_WrapperPacket::default_instance_ = NULL;

SSL_WrapperPacket* SSL_WrapperPacket::New() const {
  return new SSL_WrapperPacket;
}

void SSL_WrapperPacket::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (_has_bit(0)) {
      if (detection_ != NULL) detection_->::SSL_DetectionFrame::Clear();
    }
    if (_has_bit(1)) {
      if (geometry_ != NULL) geometry_->::SSL_GeometryData::Clear();
    }
    if (_has_bit(2)) {
      if (refbox_ != NULL) refbox_->::Refbox_Log::Clear();
    }
    if (_has_bit(3)) {
      if (aitogui_ != NULL) aitogui_->::AIToGUI::Clear();
    }
    if (_has_bit(4)) {
      if (aitoradio_ != NULL) aitoradio_->::AIToRadio::Clear();
    }
    if (_has_bit(5)) {
      if (aitosim_ != NULL) aitosim_->::AIToSim::Clear();
    }
    if (_has_bit(6)) {
      if (guitoai_ != NULL) guitoai_->::GUIToAI::Clear();
    }
    if (_has_bit(7)) {
      if (simtotracker_ != NULL) simtotracker_->::SimToTracker::Clear();
    }
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (_has_bit(8)) {
      if (trackertoai_ != NULL) trackertoai_->::TrackerToAI::Clear();
    }
    if (_has_bit(9)) {
      if (aitotracker_ != NULL) aitotracker_->::AIToTracker::Clear();
    }
    if (_has_bit(10)) {
      if (radiototracker_ != NULL) radiototracker_->::RadioToTracker::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool SSL_WrapperPacket::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .SSL_DetectionFrame detection = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_detection()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_geometry;
        break;
      }
      
      // optional .SSL_GeometryData geometry = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_geometry:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_geometry()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_refbox;
        break;
      }
      
      // optional .Refbox_Log refbox = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_refbox:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_refbox()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_aiToGui;
        break;
      }
      
      // optional .AIToGUI aiToGui = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_aiToGui:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_aitogui()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_aiToRadio;
        break;
      }
      
      // optional .AIToRadio aiToRadio = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_aiToRadio:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_aitoradio()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(50)) goto parse_aiToSim;
        break;
      }
      
      // optional .AIToSim aiToSim = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_aiToSim:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_aitosim()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(58)) goto parse_guiToAi;
        break;
      }
      
      // optional .GUIToAI guiToAi = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_guiToAi:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_guitoai()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(66)) goto parse_simToTracker;
        break;
      }
      
      // optional .SimToTracker simToTracker = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_simToTracker:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_simtotracker()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(74)) goto parse_trackerToAi;
        break;
      }
      
      // optional .TrackerToAI trackerToAi = 9;
      case 9: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_trackerToAi:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_trackertoai()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(82)) goto parse_aiToTracker;
        break;
      }
      
      // optional .AIToTracker aiToTracker = 10;
      case 10: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_aiToTracker:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_aitotracker()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(90)) goto parse_radioToTracker;
        break;
      }
      
      // optional .RadioToTracker radioToTracker = 11;
      case 11: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_radioToTracker:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_radiototracker()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void SSL_WrapperPacket::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .SSL_DetectionFrame detection = 1;
  if (_has_bit(0)) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->detection(), output);
  }
  
  // optional .SSL_GeometryData geometry = 2;
  if (_has_bit(1)) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->geometry(), output);
  }
  
  // optional .Refbox_Log refbox = 3;
  if (_has_bit(2)) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->refbox(), output);
  }
  
  // optional .AIToGUI aiToGui = 4;
  if (_has_bit(3)) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->aitogui(), output);
  }
  
  // optional .AIToRadio aiToRadio = 5;
  if (_has_bit(4)) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, this->aitoradio(), output);
  }
  
  // optional .AIToSim aiToSim = 6;
  if (_has_bit(5)) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      6, this->aitosim(), output);
  }
  
  // optional .GUIToAI guiToAi = 7;
  if (_has_bit(6)) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      7, this->guitoai(), output);
  }
  
  // optional .SimToTracker simToTracker = 8;
  if (_has_bit(7)) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      8, this->simtotracker(), output);
  }
  
  // optional .TrackerToAI trackerToAi = 9;
  if (_has_bit(8)) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      9, this->trackertoai(), output);
  }
  
  // optional .AIToTracker aiToTracker = 10;
  if (_has_bit(9)) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      10, this->aitotracker(), output);
  }
  
  // optional .RadioToTracker radioToTracker = 11;
  if (_has_bit(10)) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      11, this->radiototracker(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* SSL_WrapperPacket::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional .SSL_DetectionFrame detection = 1;
  if (_has_bit(0)) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->detection(), target);
  }
  
  // optional .SSL_GeometryData geometry = 2;
  if (_has_bit(1)) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->geometry(), target);
  }
  
  // optional .Refbox_Log refbox = 3;
  if (_has_bit(2)) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->refbox(), target);
  }
  
  // optional .AIToGUI aiToGui = 4;
  if (_has_bit(3)) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->aitogui(), target);
  }
  
  // optional .AIToRadio aiToRadio = 5;
  if (_has_bit(4)) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        5, this->aitoradio(), target);
  }
  
  // optional .AIToSim aiToSim = 6;
  if (_has_bit(5)) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        6, this->aitosim(), target);
  }
  
  // optional .GUIToAI guiToAi = 7;
  if (_has_bit(6)) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        7, this->guitoai(), target);
  }
  
  // optional .SimToTracker simToTracker = 8;
  if (_has_bit(7)) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        8, this->simtotracker(), target);
  }
  
  // optional .TrackerToAI trackerToAi = 9;
  if (_has_bit(8)) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        9, this->trackertoai(), target);
  }
  
  // optional .AIToTracker aiToTracker = 10;
  if (_has_bit(9)) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        10, this->aitotracker(), target);
  }
  
  // optional .RadioToTracker radioToTracker = 11;
  if (_has_bit(10)) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        11, this->radiototracker(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int SSL_WrapperPacket::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .SSL_DetectionFrame detection = 1;
    if (has_detection()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->detection());
    }
    
    // optional .SSL_GeometryData geometry = 2;
    if (has_geometry()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->geometry());
    }
    
    // optional .Refbox_Log refbox = 3;
    if (has_refbox()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->refbox());
    }
    
    // optional .AIToGUI aiToGui = 4;
    if (has_aitogui()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->aitogui());
    }
    
    // optional .AIToRadio aiToRadio = 5;
    if (has_aitoradio()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->aitoradio());
    }
    
    // optional .AIToSim aiToSim = 6;
    if (has_aitosim()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->aitosim());
    }
    
    // optional .GUIToAI guiToAi = 7;
    if (has_guitoai()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->guitoai());
    }
    
    // optional .SimToTracker simToTracker = 8;
    if (has_simtotracker()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->simtotracker());
    }
    
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional .TrackerToAI trackerToAi = 9;
    if (has_trackertoai()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->trackertoai());
    }
    
    // optional .AIToTracker aiToTracker = 10;
    if (has_aitotracker()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->aitotracker());
    }
    
    // optional .RadioToTracker radioToTracker = 11;
    if (has_radiototracker()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->radiototracker());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SSL_WrapperPacket::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const SSL_WrapperPacket* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const SSL_WrapperPacket*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void SSL_WrapperPacket::MergeFrom(const SSL_WrapperPacket& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from._has_bit(0)) {
      mutable_detection()->::SSL_DetectionFrame::MergeFrom(from.detection());
    }
    if (from._has_bit(1)) {
      mutable_geometry()->::SSL_GeometryData::MergeFrom(from.geometry());
    }
    if (from._has_bit(2)) {
      mutable_refbox()->::Refbox_Log::MergeFrom(from.refbox());
    }
    if (from._has_bit(3)) {
      mutable_aitogui()->::AIToGUI::MergeFrom(from.aitogui());
    }
    if (from._has_bit(4)) {
      mutable_aitoradio()->::AIToRadio::MergeFrom(from.aitoradio());
    }
    if (from._has_bit(5)) {
      mutable_aitosim()->::AIToSim::MergeFrom(from.aitosim());
    }
    if (from._has_bit(6)) {
      mutable_guitoai()->::GUIToAI::MergeFrom(from.guitoai());
    }
    if (from._has_bit(7)) {
      mutable_simtotracker()->::SimToTracker::MergeFrom(from.simtotracker());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from._has_bit(8)) {
      mutable_trackertoai()->::TrackerToAI::MergeFrom(from.trackertoai());
    }
    if (from._has_bit(9)) {
      mutable_aitotracker()->::AIToTracker::MergeFrom(from.aitotracker());
    }
    if (from._has_bit(10)) {
      mutable_radiototracker()->::RadioToTracker::MergeFrom(from.radiototracker());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void SSL_WrapperPacket::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SSL_WrapperPacket::CopyFrom(const SSL_WrapperPacket& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SSL_WrapperPacket::IsInitialized() const {
  
  if (has_detection()) {
    if (!this->detection().IsInitialized()) return false;
  }
  if (has_geometry()) {
    if (!this->geometry().IsInitialized()) return false;
  }
  if (has_refbox()) {
    if (!this->refbox().IsInitialized()) return false;
  }
  if (has_aitogui()) {
    if (!this->aitogui().IsInitialized()) return false;
  }
  if (has_aitoradio()) {
    if (!this->aitoradio().IsInitialized()) return false;
  }
  if (has_aitosim()) {
    if (!this->aitosim().IsInitialized()) return false;
  }
  if (has_guitoai()) {
    if (!this->guitoai().IsInitialized()) return false;
  }
  if (has_simtotracker()) {
    if (!this->simtotracker().IsInitialized()) return false;
  }
  if (has_trackertoai()) {
    if (!this->trackertoai().IsInitialized()) return false;
  }
  if (has_aitotracker()) {
    if (!this->aitotracker().IsInitialized()) return false;
  }
  if (has_radiototracker()) {
    if (!this->radiototracker().IsInitialized()) return false;
  }
  return true;
}

void SSL_WrapperPacket::Swap(SSL_WrapperPacket* other) {
  if (other != this) {
    std::swap(detection_, other->detection_);
    std::swap(geometry_, other->geometry_);
    std::swap(refbox_, other->refbox_);
    std::swap(aitogui_, other->aitogui_);
    std::swap(aitoradio_, other->aitoradio_);
    std::swap(aitosim_, other->aitosim_);
    std::swap(guitoai_, other->guitoai_);
    std::swap(simtotracker_, other->simtotracker_);
    std::swap(trackertoai_, other->trackertoai_);
    std::swap(aitotracker_, other->aitotracker_);
    std::swap(radiototracker_, other->radiototracker_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata SSL_WrapperPacket::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = SSL_WrapperPacket_descriptor_;
  metadata.reflection = SSL_WrapperPacket_reflection_;
  return metadata;
}


// @@protoc_insertion_point(namespace_scope)

// @@protoc_insertion_point(global_scope)
